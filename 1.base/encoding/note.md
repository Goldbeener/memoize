# 字符集 Charset

计算机中存储的信息都是以二进制数表示的

英文、中文、各种语言及其符号都是二进制转换的结果

按照一定规则将字符转换成二进制数存储起来，称为`字符编码`
按照规则将二进制数转换成字符绘制出来，称为`字符解码`

**字符集**：一系列抽象字符与二进制数的映射关系的`集合`。
**字符编码**：存储字符对应的二进制数的`规则`。

+ `ASCII` 最早英语字符与二进制数的映射关系，共128个字符
+ `GB2312`
  + 7000 多个简体汉字字符
  + GBK 微软实现，对GB2312的扩展
+ `BIG5`
  + 繁体中文字符集
+ `GB18030`
  + 完全兼容GB2312
  + 基本兼容GBK
  + 收录汉字字符70244个
+ `Unicode` 大一统的字符集，世界上所有语种的所有字符及其对应的二进制数维护在一起，得到一个通用的字符集，在任何情况下都能正确展示

除了`Unicode`之外的其他字符集，在定义的时候，配套定义了编码规范，
但是Unicode字符集是没有定义编码规范的，根据对unicode的不同编码方案，产生了utf-8、utf-16、utf-32等

## 字符编码

+ `ASCII` 7bit存储、解析码点
+ `GBX`
  + `GB2312` 2字节(高低字节、7位编码)存储码点、解析码点 （最高位都是1，低7位是有效位）
  + `GB18030` 124字节变长编码
+ `BIG5` 2字节（双8码、高低字节） 存储、解析码点
+ `Unicode`

### Unicode

国际标准字符集，
将世界各种语言的每个字符定义一个唯一的编码
以满足跨语言、跨平台的文本信息转换

旨在统一过去和现在所有的人类语言，使其能够在计算机上是用的标准
在实践中，Unicode是一个将不同字符分配给唯一数字编号的表格

字符对应的数字编号称为`码点`(Code Point)

因此Unicode其实是一个字符与数字的映射关系 `字符⟷数字码点`

编码范围： `0x0000 - 0x10FFFF`; 可以容纳110w+的字符(1114111个字符)

每个字符的编码，对应一个二进制数，为了便于展示，使用的是对应的16进制数展示。

> 字符集是字符与二进制码的映射关系
> 字体文件是码点与图形的映射关系，如果一个字体文件内没有对应字符的码点与图形映射，那就不能正常的渲染对应的字符

**Unicode与其他的字符集的区别是**
unicode只是字符集规范，
只定义了字符与二进制码的映射关系，并没有规定二进制码的存储方式。

> 其他的GBxx是字符集和存储方式合集，既定义了二进制码也规定了二进制码的存储方式

#### 表达方式

##### U+表示法

`U+<16进制表示的码点值>`

以`U+`开头，后面紧跟4-6位十六进制数字
`U+`代表是Unicode编码
`<16进制表示的码点值>` 表示具体是哪个字符, 数字值是字符对应的码点值

##### \u表示法

`\u<16进制>`

以`\u`开头，后面紧跟`4位`16进制数字 (**注意一定是4位**)
基本平面（小于U+FFFF）；只需要一组就可以
超过基本平面的扩展字符，需要使用多组代理对 ,例如 `\uD83D\uDE00`，代表 😀（U+1F600）

一般在文档、规范和技术资料中，使用U+表示法
在编程语言和字符串字面量中，嵌入使用\u表示法

#### 注意点

Unicode 是基于区域设置的
会将相同的码点分配给不同的字符，
因此使用Unicode时，首先应该确定区域

#### 平面Plane

110W+的字符集，分为17个平面，也就是17组
Plane 0 Basic Multilingual Plane (BMP)

已定义大约17w个码位，大约占比15%
另外有11%用于私有使用

剩余大约80w码位没有分配，可能在未来变成字符

##### 私用区

为应用开发人员保留的，Unicode自己永远不会占用

例如Unicode中没有苹果logo的定义，因此Apple将其放在私用区中的`U+F8FF`
只有在MacOS中可以正常展示，其他系统中不能正常展示

私用区主要由图标字体使用

字符集只是维护字符与二进制数的映射关系，并不规定这些二进制数如何存储。`不同的存储方式称为不同字符编码规范`

#### 扩展字素簇 字素 字位

在特定书写系统的上下文中`最小的可区分的书写单位`
基本上，字素是用户认为是单个字符的东西

一个字素是由一个或多个Unicode码点的序列，必须被视为一个单独的、不可分割的字符

## 字符编码规范 Character Encoding Forms

字符编码方案

知道了某个字符的码点，那么如何存储呢？

因为unicode的码点值可以有1-3个字节，
如何正确识别某个3字节的数据是代表3个1字节字符
还是1个3字节字符
还是1个2字节字符+1个1字节字符？

这就是编码规范的作用
`最终的目的都是：将码点作为字节进行编码`

常用的编码规范

+ `UTF-8`
+ `UTF-16`
+ `UTF-32`

### UTF-32

Unicode Transformation Format - 32-bit

utf-32 规范，规定所有的unicode码点都使用32位4字节空间来存储，位数不够的左边使用0来填充

因为常用的字符在BMP区，只需要2字节即可，所以utf-32规范会造成大量的空间浪费

### UTF-16

+ 常见的字符 使用双字节16bit存储、解析
+ 常见字符之外的，使用4字节存储、解析

UTF-16 编码实现

```js
// 单个字符的 UTF-16 编码
const char = '\u0041';
console.log(char.charCodeAt(0).toString(16)); // 41

// 大于 0xFFFF 的字符的 UTF-16 编码
const codePoint = 0x1F600;
const highSurrogate = Math.floor((codePoint - 0x10000) / 0x400) + 0xD800;
const lowSurrogate = ((codePoint - 0x10000) % 0x400) + 0xDC00;
const utf16 = String.fromCharCode(highSurrogate, lowSurrogate);
console.log(utf16.charCodeAt(0).toString(16)); // d83d
console.log(utf16.charCodeAt(1).toString(16)); // de00
```

### UTF-8

可变长度字符编码，使用1-4个字节存储、解析字符

2个规则

+ 单字节字符，第一位设为0，低7位为该字符的unicode码点
+ n字节字符，前n位都是1， n+1位设为0，后面字节的前两位设为10， 剩下的二进制位，代表该字符的unicode码点

## 相关字符串方法

字符串的两个最重要的视图是字节（分配内存/复制/编码/解码）和扩展字位簇（所有语义操作）

`JS中使用UTF-16编码`，每一个unicode字符可能使用1-2个码元 （基本平面使用1个码元2个字节； 扩展平面。用2个码元4个字节）
`码元` 代码单元 UTF-16 code unit 每个码元2个字节

`code point` 码点，字符在字符集内被分配的序列号

### str.length

`str.length` **返回字符串中UTF-16代码单元的个数，也就是码元的个数**
JS中使用UTF-16编码字符

`str.charAt(index)` 返回字符串中直接位置的字符

`str.charCodeAt(index)` 返回字符串指定位置`码元`对应的10进制整数
js中的字符串，基本面字符都是使用1个码元(2个字节存储)，扩展面的使用2个码元(4字节存储)
charCodeAt 会返回字符串对应位置的码元对应的10进制数

`str.codePointAt(pos)` 返回字符串指定位置字符的`码点`对应的10进制整数
扩展面的字符组成的字符串会有错位的问题

> 如果codePointAt() 参数默认是0
> 如果pos位置是字符的高端，返回整个字符完整的码点值
> 如果pos位置是字符的低端，返回字符低端码点值
>
> charCodeAt 与 codePointAt 在基本平面区域表现一致
> 在扩展平面，要使用codePointAt， charCodeAt处理不了
>
> charCode 和 codePoint 关系
> codePoint是对charCode增强版，在基本平面，charCode 和 codePoint等同
> 但是在扩展平面charCode无法正确表示，因此才新增了codePoint

`String.formCharCode(index)` 返回码元号对应的字符串
`String.formCodePoint(index)` 返回码点数对应的字符串

```js
'𠮶𠮷' 这个字符串，表面有2个元素组成，但是每个元素都是在拓展面
第一个字符，由2个码元组成，
'𠮶𠮷'.codePointAt(0) 返回的是`𠮶`的完整码点
'𠮶𠮷'.codePointAt(1) 返回的是`𠮶`的部分码点，因为js中是以码元区分的，1这个位置实际是`𠮶`的码元所在
```

+ 在0x0000-0xfffff 范围内的字符，charCodeAt 与 codePointAt返回一样

## 相关写法

`\uXXXX` 字符的16进制unicode编码值
`\u{code point(16进制)}`

这两种写法能被js识别

`U+<code point 16进制>`
unicode 码点 指代一个确定的unicode字符，但是这个写法并不能在js中识别

```js
<U+6c49>  代表 '汉' 这个字符 

// 这两种写法可以在js中识别
const a = '\u6c49'
const b = '\u{6c49}'

```

## 字体文件

### 字体文件设计要素

一个字体文件通常包含以下影响字体呈现的因素

1. `字体类型` 决定字体整体外观，包括衬线和非衬线
2. `字形` 决定字体的具体形状和样式，如圆润、方正、斜体等
3. `字体大小` 指字体的相对大小，通常以点数或像素为单位
   1. [font metrics](../css/font.md)
4. `字体粗细` 字体粗细程度
5. `字体间距` 字符之间的距离和行间距
6. `字符集` 指字体文件包含的字符集合，不同的字体包含不同的字符集，只有在字符集内的字符才能被正常渲染

## 生僻字

### 产生的原因

1. 浏览器默认加载一组字体文件，这些字体文件包含大多数常用的字符，但是不包含所有的生僻字，因此没有对应生僻字字符的字形信息，无法渲染
2. 页面编码和字符编码问题，导致无法匹配生僻字字符，因而无法正确渲染

web页面编码基本上是`utf-8`
字体文件一般是使用unicode编码
这样web页面和字体文件可以匹配

### 解决方案

1. 使用字体文件，使用`@font-face`额外加载包含生僻字的字体文件
   1. 会产生额外的网页加载性能损耗
2. 图像替代，将无法展示的生僻字，使用图像替代
   1. 影响网页的可访问性，影响SEO

# 参考文章

+ [Unicode 的基本知识](https://blog.xinshijiededa.men/unicode/)
