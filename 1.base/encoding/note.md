# 字符集 Charset

计算机中存储的信息都是以二进制数表示的

英文、中文、各种语言及其符号都是二进制转换的结果

按照一定规则将字符转换成二进制数存储起来，称为`字符编码`
按照规则将二进制数转换成字符绘制出来，称为`字符解码`

**字符集**：一系列抽象字符与二进制数的映射关系的`集合`。
**字符编码**：存储字符对应的二进制数的`规则`。

+ `ASCII` 最早英语字符与二进制数的映射关系，共128个字符
+ `GB2312`
  + 7000 多个简体汉字字符
  + GBK 微软实现，对GB2312的扩展
+ `BIG5`
  + 繁体中文字符集
+ `GB18030`
  + 完全兼容GB2312
  + 基本兼容GBK
  + 收录汉字字符70244个
+ `Unicode` 大一统的字符集，世界上所有语种的所有字符及其对应的二进制数维护在一起，得到一个通用的字符集，在任何情况下都能正确展示

除了`Unicode`之外的其他字符集，在定义的时候，配套定义了编码规范，
但是Unicode字符集是没有定义编码规范的，根据对unicode的不同编码方案，产生了utf-8、utf-16、utf-32等

## 字符编码

+ `ASCII` 7bit存储、解析码点
+ `GBX`
  + `GB2312` 2字节(高低字节、7位编码)存储码点、解析码点 （最高位都是1，低7位是有效位）
  + `GB18030` 124字节变长编码
+ `BIG5` 2字节（双8码、高低字节） 存储、解析码点
+ `Unicode`

## Unicode

国际标准字符集，将世界各种语言的每个字符定义一个唯一的编码，称为`码点`(Code Point)

以满足跨语言、跨平台的文本信息转换

编码范围： `0x0000 - 0x10FFFF`; 可以容纳100w+的字符(1114111个字符)

每个字符的编码，对应一个二进制数，为了便于展示，使用的是对应的16进制数展示。

> 字符集是字符与二进制码的映射关系
> 字体文件是码点与图形的映射关系，如果一个字体文件内没有对应字符的码点与图形映射，那就不能正常的渲染对应的字符

**Unicode与其他的字符集的区别是**
unicode只是字符集规范，
只定义了字符与二进制码的映射关系，并没有规定二进制码的存储方式。

> 其他的GBxx是字符集和存储方式合集，既定义了二进制码也规定了二进制码的存储方式

### 平面Plane

100W+的字符集，分为17个平面，也就是17组
Plane 0 Basic Multilingual Plane (BMP)

字符集只是维护字符与二进制数的映射关系，并不规定这些二进制数如何存储。`不同的存储方式称为不同字符编码规范`

## 字符编码规范 Character Encoding Forms

字符编码方案

知道了某个字符的码点，那么如何存储呢？

因为unicode的码点值可以有1-3个字节，如何正确识别某个3字节的数据是代表3个1字节字符还是1个3字节字符还是1个2字节字符+1个1字节字符？

这就是编码规范的作用

常用的编码规范

+ `UTF-8`
+ `UTF-16`
+ `UTF-32`

### UTF-32

Unicode Transformation Format - 32-bit

utf-32 规范，规定所有的unicode码点都使用32位4字节空间来存储，位数不够的左边使用0来填充

因为常用的字符在BMP区，只需要2字节即可，所以utf-32规范会造成大量的空间浪费

### UTF-16

+ 常见的字符 使用双字节16bit存储、解析
+ 常见字符之外的，使用4字节存储、解析

UTF-16 编码实现 
```js
// 单个字符的 UTF-16 编码
const char = '\u0041';
console.log(char.charCodeAt(0).toString(16)); // 41

// 大于 0xFFFF 的字符的 UTF-16 编码
const codePoint = 0x1F600;
const highSurrogate = Math.floor((codePoint - 0x10000) / 0x400) + 0xD800;
const lowSurrogate = ((codePoint - 0x10000) % 0x400) + 0xDC00;
const utf16 = String.fromCharCode(highSurrogate, lowSurrogate);
console.log(utf16.charCodeAt(0).toString(16)); // d83d
console.log(utf16.charCodeAt(1).toString(16)); // de00
```

### UTF-8

可变长度字符编码，使用1-4个字节存储、解析字符

2个规则

+ 单字节字符，第一位设为0，低7位为该字符的unicode码点
+ n字节字符，前n位都是1， n+1位设为0，后面字节的前两位设为10， 剩下的二进制位，代表该字符的unicode码点

## 相关字符串方法

`JS中使用UTF-16编码`，每一个unicode字符可能使用1-2个码元 （基本平面使用1个码元2个字节； 扩展平面。用2个码元4个字节）
`码元` 代码单元 UTF-16 code unit 每个码元2个字节

`code point` 码点，字符在字符集内被分配的序列号

`str.length` 返回字符串中UTF-16代码单元的个数，也就是码元的个数
`str.charAt(index)` 返回字符串中直接位置的字符

`str.charCodeAt(index)` 返回字符串指定位置`码元`对应的10进制整数
js中的字符串，基本面字符都是使用1个码元(2个字节存储)，扩展面的使用2个码元(4字节存储)
charCodeAt 会返回字符串对应位置的码元对应的10进制数

`str.codePointAt(pos)` 返回字符串指定位置字符的`码点`对应的10进制整数
扩展面的字符组成的字符串会有错位的问题

> 如果codePointAt() 参数默认是0
> 如果pos位置是字符的高端，返回整个字符完整的码点值
> 如果pos位置是字符的低端，返回字符低端码点值
>
> charCodeAt 与 codePointAt 在基本平面区域表现一致
> 在扩展平面，要使用codePointAt， charCodeAt处理不了
>
> charCode 和 codePoint 关系
> codePoint是对charCode增强版，在基本平面，charCode 和 codePoint等同
> 但是在扩展平面charCode无法正确表示，因此才新增了codePoint

`String.formCharCode(index)` 返回码元号对应的字符串
`String.formCodePoint(index)` 返回码点数对应的字符串

```js
'𠮶𠮷' 这个字符串，表面有2个元素组成，但是每个元素都是在拓展面
第一个字符，由2个码元组成，
'𠮶𠮷'.codePointAt(0) 返回的是`𠮶`的完整码点
'𠮶𠮷'.codePointAt(1) 返回的是`𠮶`的部分码点，因为js中是以码元区分的，1这个位置实际是`𠮶`的码元所在
```

+ 在0x0000-0xfffff 范围内的字符，charCodeAt 与 codePointAt返回一样

## 相关写法

`\uXXXX` 字符的16进制unicode编码值
`\u{code point(16进制)}`

这两种写法能被js识别

`U+<code point 16进制>` unicode 码点 指代一个确定的unicode字符，但是这个写法并不能在js中识别

```js
<U+6c49>  代表 '汉' 这个字符 

// 这两种写法可以在js中识别
const a = '\u6c49'
const b = '\u{6c49}'

```

## 字体文件

### 字体文件设计要素
一个字体文件通常包含以下影响字体呈现的因素
1. `字体类型` 决定字体整体外观，包括衬线和非衬线
2. `字形` 决定字体的具体形状和样式，如圆润、方正、斜体等
3. `字体大小` 指字体的相对大小，通常以点数或像素为单位
   1. [font metrics](../css/font.md)
4. `字体粗细` 字体粗细程度
5. `字体间距` 字符之间的距离和行间距
6. `字符集` 指字体文件包含的字符集合，不同的字体包含不同的字符集，只有在字符集内的字符才能被正常渲染


## 生僻字
### 产生的原因

1. 浏览器默认加载一组字体文件，这些字体文件包含大多数常用的字符，但是不包含所有的生僻字，因此没有对应生僻字字符的字形信息，无法渲染
2. 页面编码和字符编码问题，导致无法匹配生僻字字符，因而无法正确渲染

web页面编码基本上是`utf-8`
字体文件一般是使用unicode编码
这样web页面和字体文件可以匹配

### 解决方案

1. 使用字体文件，使用`@font-face`额外加载包含生僻字的字体文件
   1. 会产生额外的网页加载性能损耗
2. 图像替代，将无法展示的生僻字，使用图像替代
   1. 影响网页的可访问性，影响SEO