# 权衡的艺术

全局把控： 视图层框架的定位与方向

## Chapter 1
1. 命令式与声明式
   1. 性能与可维护性的权衡
2. 虚拟DOM的定位
3. 编译时和运行时



### 命令式与声明式
命令式的性能更高，直接进行操作DOM
声明式相对性能低 `找出DOM diff + 操作DOM` 多了一步根据声明式的写法找出需要操作的dom这一步骤

但是声明式关注点是在数据状态上，拥有更好的可维护性

### [虚拟DOM](../virtual-dom.md)
声明式       
性能损耗点在于多了一步找出dom diff的操作，     
这一步性能损耗尽可能小，就能够使声明式的性能逼近命令式

`虚拟dom是最小化dom diff性能损耗的其中一个方案`

原理是： 
纯js操作性能远远高于dom操作性能；
在js层维护当前和上一个dom结构数据，通过js计算对比找出最小化diff
然后按需更新dom

尤其在更新dom上有更好的表现

> 以上是虚拟DOM的一方面应用
> 还有一个应用是在跨端实现 

### 编译时和运行时
是框架的选择

运行时：在项目运行的过程中实时的将开发源码转换成最终可执行产物；
    有运行中的性能消耗
    并且没有编译过程，无法进行抽象、优化
编译时：开发源代码经过编译之后，在生产环境直接执行，直接将声明式的开发代码转换成真实的dom操作等
    无运行中性能消耗
    但是不够灵活，用户提供的东西不经过编译不能使用

vue 运行时+编译时
编译时主要是将模版文件转换成对应的数据结构；
然后在运行时，使用这些数据结构render  （`vue是在运行时做diff、然后将代码转换成底层原生js命令式代码`）
并且在编译时，可以对内容做标记，对一些静态资源做一些固化，提高运行时效率

> vue时编译时+运行时，单指对sfc模版文件的提前编译，编译完成之后仅打包runtime
> 在编译完成之后，变成了纯运行时
> 纯运行时 仅将data render成dom结构

vue 官网术语
+ 编译器 将模板文件转换成js渲染函数 （渲染函数的执行结果就是虚拟dom）
+ 运行时 创建vue实例，渲染并处理虚拟dom的代码

> svelte 是纯编译时


# 核心要素
1. 框架基本功能
2. 构建产物格式定制
   1. global iife
   2. esm   [package.json - module]
   3. esm-browser
   4. cjs
3. 完善的日志信息
4. 错误处理
   1. 统一错误处理
5. HMR
6. tree-shaking
   1. esm tree-shaking 
   2. 副作用 调用函数会对外部产生影响
   3. dce 实现？ dce与tree-shaking ？？？ [tree-shaking](../../../../../4.engineering/webpack/tree-shaking.md)
7. 尽可能小的包体积
   1. tree-shaking
   2. 特性开关


# Vue3的设计思路

声明式的描述ui
1. 模板描述    ---  sfc思路
2. js对象描述  ---  虚拟dom的思路

而最终，sfc模板文件还是通过**编译器**被编译成渲染函数（js对象），最终再渲染成真实dom，实现渲染

**编译器**

组件要渲染的内容是通过**渲染函数**来描述的；也就是render函数。

render函数的返回值是**虚拟dom**

vue通过**渲染器**将虚拟dom转换成真实dom并渲染

**渲染器**
1. 虚拟dom转换成真实dom
2. dom diff 更新

**组件的本质** 一组dom元素的封装