# Virtual DOM 

## 优势在哪？
**前端操作DOM耗费性能？**

1. DOM引擎 和 js引擎 共同工作在同一线程： 主线程；任何dom操作的api调用，需要先将js数据结构转换成DOM数据结构，再挂起js引擎并启动DOM引擎；执行过后将返回值格式化为js引擎，重启js引擎继续执行。 这种上下文切换很耗费性能
2. dom api 操作涉及页面布局的重新绘制，重排；重绘重排更耗费性能。

**对策，解决方案？**
虚拟dom是其中一种解决方案。

使用js数据结构，描述dom结构，发生变化时，并不会立马重绘重排，在一定时间段内，多次dom更新只会缓存在js数据结构上；然后再与真实dom做diff操作，只渲染变动的最小部分。
这样忽略了中间过程，减少了js引擎与dom引擎的切换，并且最小化了dom操作。

以上是虚拟dom的优势


> 这个地方


## 问题点？
虚拟dom 什么时候转换成 真实dom？ nextTick？



**一个tick具体是什么时机？**
本次loop中，主线程上任务执行完成，
开始清空微任务队列时， 一个tick开始；
宏任务队列中第一个任务，执行完成时，一个tick结束。

> 其实就还是一个event-loop中，主线程结束到下一个loop开始 这段时间，称之为一个tick。

process.nextTick() Vs setImmediate()
nextTick 是微任务，在本轮loop时触发；
setImmediate是宏任务，在接下来的loop内触发。
