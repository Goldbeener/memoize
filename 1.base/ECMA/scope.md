# 作用域

词法作用域
函数、变量寻值遵循词法作用域的规则;
在代码书写时就已经确定了作用域规则;

> 与之对应的是动态作用域

可能对词法作用域规则产生干扰的2个操作

+ eval 会将参数在当前位置插入，仿佛在书写的时候就在这里
+ with 会指定接下来的操作范围

这两个操作有性能问题
编译阶段，引擎会做性能优化，根据词法作用域，预先确定变量的位置，为执行时快速查找做准备；
而eval和with可能使这些优化全部没有意义，因此遇到eval、with时就不会再做优化了

`词法作用域查找`只针对`一级标识符`；
a.b
只会影响a的查找
对b的查找是对象属性访问规则，遵循`原型链查找`规则

## 作用域分类

+ 全局作用域
  + 本质上是一个函数作用域，立即执行匿名函数
+ 函数作用域
  + 函数声明
  + 函数表达式
    + 具名/匿名函数表达式
      + 具名函数表达式
        + 函数名常量化
        + 函数名私有化，外部不能访问，只有内部可以访问
    + 立即执行函数表达式
+ 块级作用域
  + with
  + try/catch
  + let
  + const

### 区分函数声明和函数表达式

看function关键字是否出现在声明中的第一个词，那么就是声明，否则就是表达式

```js
function foo() {} // 声明

var bar = function() {} // 表达式

;(function() {})();  // 表达式
;(function foo(){}); //表达式

(function(){}()) === (function(){})()
```

### with

```js
var a = 0;
var obj = {
    a: 1,
    b: 2,
};

with(obj) {
    console.log('>>>>', a); // obj作用内的a 1
}

```

### catch

```js

try {
    undefined()
} catch(e) {
    console.log(e)
}
console.log(e)
```

### for循环的作用域

```js
for(var i = 0; i< 3; i++){
 setTimeout(function(){
     console.log(i)
    }, 0)
}

// i 提升 与for循环定义平级
// 每个循环体内用的都是相同的作用域


for(let i = 0; i< 3; i++){
 setTimeout(function(){
     console.log(i)
    }, 0)
}
// 圆括号内有一个独立的作用域，在这里面声明i变量； 外部访问不到
// 每个循环体内都是独立的作用域，并且这个作用域是圆括号内的作用域的子作用域；里面也有一个同名的i变量，这个变量值是每次循环的开始时候从上次循环结束计算而来的


let i = 1;
let fns = [];

for(let i = 0; i < 10; i++) {
    fns[i] = function() {
        console.log(i);
    };
}

```

## 作用域链

函数被调用时，引擎创建一个新的执行上下文
确定当前作用域，
    如果是全局上下文，作用域链包括全局对象
    如果是函数上下文，作用域链包括函数自身的作用域和父级作用域，父级还关联自己的父级，直到全局作用域
构建作用域链
    将函数自身作用域放在链顶部，串联外部作用域，直到全局
变量查找
    在作用域链里面查找变量

### 词法作用域

变量的作用范围由其在代码中的位置决定；
意味着
当定义一个函数时，作用域链包含它所在的上下文中的变量和函数声明

这也引申出了`闭包`的概念，内部函数可以访问外部函数的变量

## 提升

在某个作用域内的`变量声明`和`函数声明` 会在编译阶段 提升在作用域顶部
函数声明 会在编译阶段 声明并赋值
变量声明 仅作声明提升 赋值操作不提升
    var 变量 初始值undefined
    let/const 变量初始值 uninitialized

同名函数声明，后来的会覆盖之前的
同名的函数声明和变量声明，后来的变量声明会被忽略; 但是在具体执行的过程中变量的赋值还是会覆盖函数声明的值

> 仅变量声明 和 函数声明会提升
> 函数表达式不会，即使是具名函数表达式也不会

```js
console.log(foo);  
function foo() {
    console.log('foo');
}
var foo = 2;
console.log(foo);

/**
 * 编译阶段
 *      foo函数声明先被提升，并且直接赋值函数体
 *      同名foo变量声明会被忽略；因为当前作用域已经存在一个foo声明
 * 
 * 执行阶段
 *      第一句log时foo还对应着函数
 *      后面又将foo赋值为2
 *      因此最后打印2
 * */ 
```
