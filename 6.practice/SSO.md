## SSO

Single Sign On 单点登录，用户在多应用系统中，在其中一个应用中完成登录，即可访问相互信任的其他所有系统。

## 关键技术点

1. 登录状态共享，一点登录，多点复用
2. token隔离，多个系统之间不是简单的共享token，一方的token泄漏，不会影响到其他系统

## 实现方案

### 单一域名

相互信任的多个系统都是在同一个域名下，可以将cookie种在相同的顶级域名下，这样多个系统之间都会共享这个登录cookie，

优点： 实现简单，前端接入成本低
缺点：没有token隔离；任何站点发生token泄漏，都会影响到其他站点

### 多域名

多域名实现单点登录，就不能简单利用cookie了；因为浏览器安全策略限制，不能跨域操作cookie

业内成熟的方案是，CAS框架（Centrl Authentication Service）

主要的思想就是在业务服务器之外，存在一个专门的认证服务；并且业务服务内嵌入了登录拦截器，用来分发、验证登录状态。

- 认证中心：独立于业务服务之外的专门的登录认证服务，
- 登录拦截器：与业务服务部署在一起，用来过验证、分发业务请求
- 用户第一次在认证中心完成登录之后，认证中心会产生一个全局会话（类似于令牌的凭证）
- 每个系统都会有对应的各自的局部会话，以此实现token隔离

具体的实现思路是：  

1. 用户访问系统A，拦截器拦截并解析请求，发现没有有效的局部会话，重定向到认证中心；
2. 认证中心监测到用户并没有登录，没有全局会话，重定向到登陆页
3. 用户在登陆页输入用户名、密码完成登录之后，认证中心建立全局会话，新建令牌并重定向到系统A；
4. 系统A发现令牌之后，拿着令牌到认证中心验证，验证通过之后建立系统A的局部会话，以cookie形式存储在客户端，后续以此正常的访问系统A内的资源；
5. 用户访问系统B；拦截器发现没有局部会话；重定向到认证中心；
6. 认证中心监测到有全局会话，新建令牌重定向到系统B；
7. 系统B拿到令牌之后到认证中心验证；成功之后，建立系统B的局部会话，之后可以正常访问系统B内资源

### Q&A

**用户在访问系统B，重定向到认证中心的时候，如何传递的身份信息？**

用户在系统A内完成登录之后，会创建一个全局会话凭证，具体来说就是会在认证中心的域名下种下一个cookie，标示用户在认证中心的身份；当用户在系统B内因为未登录而被重定向到认证中心的时候，会携带上之前种下的标示用户身份的cookie；认证中心根据该cookie会读取出对应的全局会话信息，以此来判断是否建立了全局会话，即是否完成过登录

**如何理解全局会话&局部会话&令牌？**

会话，即session，session就是更安全的cookie， 服务端cookie，本质上是一个id，在服务端内，每一个id都会对应着一段用户信息cookie；
从认证中心完成登录之后，重新跳回到业务站点时，携带了一个叫`令牌`的东西，个人理解有2个作用：
- 更安全的传输信息，不必使session信息以明文传递；
- 认证中心与业务站点通常是在不同的域名下，因为跨域的限制，认证中心无法直接在业务域名下种cookie，因此传递一段类似cookie id的信息（即令牌），业务站点再拿着这段令牌，取换取真正的cookie，并种在对应域名下。

## 单点登出

用户在一个站点登出之后，其他系统内也会自动登出。

1. 用户在站点A发起登出请求
2. 站点A服务销毁局部会话，同时通知认证中心用户登出
3. 认证中心销毁全局会话，同时通知其他系统

认证中心如何通知其他系统？

存在一个缓存系统，该缓存系统内存储着用户的最新登录状态；系统在每次验证局部会话的时候，都会访问该缓存系统，查看该登录状态是否有效，是否已被其他系统所销毁。如果已被销毁，即使局部会话有效，也会被销毁，以此来实现关联系统的登出。

## 参考文档

[CAS实现单点登录SSO执行原理探究](https://blog.csdn.net/javaloveiphone/article/details/52439613)
