模块化解决方案：
    + AMD: `RequiereJS`
    + CommonJS: `node.js`  `Browserify`
    + UMD: AMD + CommonJS + browser/global全局
    + ES Module es6 模块规范


## CommonJS 模块规范

执行时加载， 当脚本require时，确定依赖关系，全部执行模块代码，
执行过程中 遇到require时，暂停本模块的执行，开始进入依赖的模块，直到依赖的模块执行完毕，再继续执行
并且在内存中生成一个对象 导出的内容copy在该对象上，后续的再次require直接从这个对象上获取，不会再次执行脚本的内容

遇到循环加载的时候，只输出已经执行的部分，还未执行的部分不会执行
如果已经执行的部分没有导出，那么模块值就是null，强行调用会出现报错

可以写在if条件中

处理循环依赖

[demo](../../test/require/main.js);

## ES Modules
[es module](esm.md)

静态导入文件，在编译阶段确定依赖关系

遇到import加载模块的命令时，不会去执行模块，而是生成一个引用，等到真正需要的时候再去模块里面取值

所以 import 模块引用出现循环引用的时候，也可能正常执行

`动态引用`，不会缓存模块值

不能写在if条件中，只能在文件顶部

### import steps
1. Parsing: 编译阶段，静态分析代码中的语法错误，比如模块导入中使用了运算等非法操作
2. Loading: 递归的加载依赖模块，a->b->c....
3. Linking: 将每个模块的导出声明 绑定到一个scope内；
4. Runtime: 执行每个依赖的模块
5. 真正在引用的时候，import语句其实什么都没做，前置工作已经把导入完成了，后面就是主模块的代码执行
   1. 主模块在依赖导入完成之前，什么都不会做，不会执行代码 [依赖模块内有异步行为的话，会仅触发，不会等待完整的异步回调]


import/export 
1. import、export 必须在文件顶层，不能写在条件语句中或者函数内
   1. 即使import语句不是写在模块的最前方，也是会被提升的，在他之前的代码不会执行，直到import引入的模块执行完毕
2. 所有依赖的模块，都必须预先加载、解析、链接，在主模块执行之前
   1. 主模块无法做到在依赖加载之前，执行某些代码
   2. 也没有模块加载的控制权
3. 即使引入了某个模块，但是并没有使用引入的值，但是引入的模块其实也被执行了


webpack的代码分割，是对静态模块的补充，可以实现类似对模块的加载控制，
对模块懒加载、按需加载


