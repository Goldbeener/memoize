# HTTPS
HTTP + SSL/TLS

HTTP报文经过SSL/TLS层加密之后，再传递给TCP层处理

## 背景
HTTP明文传输数据，在链路中的任一环节都有可能被窃取、篡改、伪造

## 加密
### 对称加密
`数据的加解密都是使用相同的密钥`

1. 浏览器发送支持的加密套件+client-random
2. 服务器选择其中的一个加密套件，然后返回一个server-random
3. 浏览器和服务器分别返回确认消息

双方通过client-random + server-random 再使用相同的加密套件生成秘钥 master secret；
之后，双方的通信使用这个秘钥加密报文

**缺陷**
在协商的过程中，都还是明文传输的，因此两端的随机数，以及协商使用的加密套件是公开的
黑客可以拿到这些信息，自己生成秘钥，用来解密，因此通信过程也是可以被破解的

### 非对称加密
非对称加密算法有2个秘钥，公钥和私钥
使用公钥加密的信息，只能用私钥来解密；
反之，使用私钥加密的信息，只能使用公钥来解密

通常情况下，服务器持有一对公私钥，并将公钥公开

1. 浏览器发送支持的加密套件
2. 服务器选择其中的一个加密套件，然后把服务器的公钥+选择的加密套件返回给浏览器
3. 浏览器和服务器确认

这时候，浏览器获取到服务器的公钥， 在后续通信中，可以使用这个公钥来加密数据，

这能够保证，浏览器发送给服务器的信息是安全的，但是服务器返回给浏览器的信息还是不安全的

并且，非对称加密的效率是比较低的

### 对称加密+非对称加密
使用非对称加密完成对称加密需要的秘钥的传递，
然后后续的通信，使用对称加密来进行

这样既保证了双方通信的安全性，也有很很高的加密效率

1. 浏览器发送支持的对称加密套件、非对称加密套件、client随机数A
2. 服务器保存A，并且返回选择的对称加密套件、非对称加密套件、server随机数B、服务器的公钥
3. 浏览器保存B、保存服务器公钥；继续生成随机数C（有说使用A+B计算得到C），使用服务器公钥加密随机数C，返回给服务器
4. 服务器接收到加密后的C，使用自己的私钥解密，得到随机数C
5. 至此，双方都获取到了A、B、C三个数，然后使用同一套方法生成秘钥
   1. 黑客不能获取到C，因为C是使用服务器公钥加密的，只能用私钥来解密，而服务器私钥是保存在服务器端不会被获取到的

### 添加数字证书
上述的方式，正常情况下可以实现安全传输

但是，有一个问题是，黑客直接劫持dns，将目标服务器的ip地址替换成黑客的地址，黑客就可以冒充目标服务器进行通信
客户端无法识别

带来的一个问题是，服务器向浏览器证明： **我就是你想要访问的正确的目标地址**

需要引入一个第三方的权威机构，给服务器颁发一个证书。
权威机构是`CA`： `Certificate Authority`
证书是数字证书`DC`： `Digital Certificate`

当前的实践是，服务器向权威机构申请，颁发证书
1. 证书可以证明服务器的身份
2. 证书内还包含服务器的公钥

因此在上述的协商第2步
2. 服务器保存A， 选择的对称加密套件、非对称加密套件、server随机数B、**服务器的证书**
3. 浏览器接收到之后，先`验证证书`，再继续后续的流程    [证书验证步骤](#浏览器验证证书信息)
   1. 证书验证通过之后，确认了服务器的身份，并且获取到了服务器的公钥
   2. 其实还多了一个流程，就是验证颁发证书的CA是否权威可靠，否则证书也是不可信的
   3. 继续后续的流程


#### 证书获取流程以及包含的信息
1. 服务器主体公司，准备一套公钥+私钥； 私钥自己留存
2. 向CA机构提交，公钥+公司信息(站点地址等)等信息，等待认证
3. CA核实公司的信息
4. 核实通过之后，向公司签发认证后的数字证书DC，证书内包含了以下信息，有的是明文的，有的是经过CA机构私钥加密的
   1. 公司的公钥
   2. 组织信息
   3. CA信息
   4. 有效时间
   5. 证书序列号
   6. CA生成的签名（它是用CA的私钥加密的）以及签名所使用的hash函数 

#### 浏览器验证证书信息
1. 得到证书的`相关明文信息`(也是约定的几个字段信息)，然后使用生成CA签名的Hash函数，自己做一次计算，得到一个摘要A
2. 然后再利用CA的公钥，解密签名数据，得到摘要信息B
3. 对比A和B，如果一直，确认证书是没有被伪造的，（**hash摘要的作用是防篡改**） 确认证书没有被篡改之后再开始验证证书信息
4. 验证证书内的相关信息，证书的域名信息、是否过期等；（这一步**暂时确认了目标服务器是正确**的，并且证书也在有效期内）
   1. 暂时是因为，不能确定CA的权威性，如果是随随便便的CA颁发的证书的话，那么证书还是不可信的
5. 这时候确认了证书的有效性，以及CA的一些信息，但是还不确定这个CA是否足够权威和可信
6. 查找给这个CA颁发证书的CA，以及上层的CA，知道最终找到顶级的CA （验证**CA链**的可信性，直至顶层）
   1. 顶级的CA证书信息一般会内置在浏览器内

> 证书： CA会给服务器颁发证书，顶层CA也会给下属的CA颁发证书
> 顶层CA、二层CA、... N层CA，正常公司是向某个底层CA申请证书  上一层为下一层背书
> 然后验证的时候，除了验证服务器DC的有效性，还会验证颁发这个DC的CA的可靠性
> 验证方式是，一层一层向上，`直到找到浏览器内置的公认的可靠的CA`。


## 安全性
1. 机密性  加密
2. 完整性  hash摘要
3. 身份认证  证书
4. 不可否认
