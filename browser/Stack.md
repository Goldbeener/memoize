# Stack & Heap

ECMA JS语言规范中并没有关于堆和栈的标准
是js解释器（浏览器厂商）实现的

## 是什么？
Heap: 堆 
  1. 一块large内存区域，存放任意数据
  2. 无顺序，随意存取
  3. 存取效率低
  4. 为了高效存取，一般会把数据对应的指针存储在栈内
Stack： 栈 
  1. 一块small内存区域，一般存储存储简单数据
  2. 有顺序，先进后出操作模式 FILO
  3. 存取效率高
  4. 主线程初始化的时候被创建；一个线程只有一个

堆和栈本质上都是内存空间，对应内存条的实体存储
只不过，`栈`是人为控制划分出来的一段内存空间，有`连续`、`先进后出`的特点

### stack VS call stack
在JS中
栈空间 === 调用栈 === 执行栈
用来存储`执行上下文`的 即context

> 在js内context 有 全局执行上下文、函数执行上下文、eval执行上下文
> 本质上都是 函数上下文

每一个执行上下文 context 本质都是一个对象；
然后在这个对象里面，有函数能访问的对象集合
+ 函数自身变量环境
  + 函数参数
  + 函数内部声明变量
  + 闭包
+ 词法作用域变量环境
  + 外层作用域

**栈的空间不会太大，在其中存放的都是基本数据类型的值，和引用类型的内存指针**


## 变量存储位置
什么样的数据存在栈内？
什么样的数据存在堆内？

除了局部变量，其他的全部存储在堆内；
基本类型存储在栈内，存储的是真实值；
引用类型存储在栈中存储的是指针地址；真实内容存储在堆内。

### 说法
1. **基本类型数据其实也是存储在堆内的**
因为查看v8引擎源码；发现基本类型的数据的初始化，还是使用对应的类实例化的；
引擎需要维护数据除了值之外的额外信息，因此，基本类型数据在引擎层也是以对象形式维护的

只不过有优化算法，某些基本类型长久以来就是以基本值出现，没有被动态改编为引用类型；
会在移动到栈内存储，提高存取效率 

查看页面内存信息？ 堆信息；栈信息

## 赋值操作

### 值为常量/字面量
```js
const a = 0;
const foo = 'bar';
const obj = { a: 1 }
```
等号右边是确定的值； 这时候是在内存中开辟新的空间，记录这些新的变量声明

### 值为变量
```js
const a = 0;
const b = a;

const obj = { a: 1 };
const ojb = obj;
```
等号右边是已经声明的变量；**这时候是把变量地址赋值给左侧**

### const机制
被const声明的变量，不允许被修改；
其实就是他的内存地址不允许改变


变量重新赋值在内存中是什么表现，是覆盖还是重写&指针替换？

## 闭包
**如何产生的？**
词法作用域的缘故，内层函数会持有外层函数的作用域；
当内层函数作为返回值，暴露给外部变量时；
外部变量也持有了外层函数的作用域；

**如何实现的？**
产生闭包现象之后，被闭包引用的变量会被存储在[[clourse]]对象内，真实值在堆内；
其他未被闭包引用的变量，正常存储在栈内
[[clourse]] 对象是存储在函数的自身变量环境内的



# GC

JS会自动做垃圾回收，不需要开发者手动释放内存占用

## 栈内存释放
栈结构维护了一个指针，指向当前正在处理的上下文结构；
在改指针之上的上下文结构被认为是无效的内存，下次需要分配栈内存的时候会直接覆盖

但是栈内变量引用的对象依旧在堆内存中占用空间

## 堆内存回收
要回收堆内存中的垃圾数据，需要使用到js中的垃圾回收器

+ 代际假说
  + 大部分对象在内存中存在时间很短
  + 不死的对象，会存在很长时间
+ 分代收集

> 代际假说总结来说就是： js堆内存中的数据，要么声明之后很快就不需要了；要么是会存在很长时间

V8引擎根据代际假说，将堆分为`新生代区域`和`老生代区域`

新生代区域内存放的是声明之后很快失效的数据  1-8M
老生代区域内存放的是存在时间很久的数据  无限

副垃圾回收器： 回收新生代的垃圾
主垃圾回收器： 回收老生代的垃圾

### 垃圾回收算法

在新生代采用以下算法**Scavenge 算法**

空间对半分，一半是对象区域，一半是空闲区域；
每一个对象声明，都会先存放在对象区域内
当对象区域快写满时，开始垃圾清理操作，对所有对象做标记，区分活动对象和非活动对象；
把活动对象按顺序复制到空闲区域；
降对象区域和空闲区域角色反转
清除空闲区域（原对象区域）内的所有遗留对象，都是非活动对象，准备下次反转


**对象晋升策略**
经历过2次垃圾回收之后，依然存在的对象，会被移动到老生代区域


在老生代采用**标记清算法**
1. 标记空间中的活动对象和非活动对象
2. 回收非活动对象占用发的内存
3. 内存整理

升级版；**标记整理算法**
标记之后，不直接回收失活对象；
而是将所有活动对象移动到一端
然后清理掉边界之外的内存；

避免出现内存碎片


# 全停顿
JS运行在单线程上；

一旦指向垃圾回收，会暂停脚本执行；
待垃圾回收完成之后，再继续执行

这种行为称之为**全停顿**

新生代空间小，且存活对象少，全停顿影响不大
老生代不一样，老生代内数据比较多，执行完一次全量的垃圾回收操作，可能会占用主线程较长的时间
会影响页面性能，造成页面、动画卡顿
# 增量标记
在老生代内，将标记过程分为多个子标记过程；
同时将垃圾回收和页面逻辑交替进行，直到所有标记完成；
最后再执行整理、清理逻辑


