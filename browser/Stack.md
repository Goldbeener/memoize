# Stack & Heap

Heap: 堆 
Stack： 栈 连续的数据结构 先进后出

堆和栈本质上都是内存空间，对应内存条的实体存储
只不过，栈是人为控制划分出来的一段内存空间，有连续、先进后出的限制

栈 和 执行栈有什么关系？
栈空间 === 调用栈 === 执行栈
用来存储`执行上下文`的 即context

> 在js内context 有 全局执行上下文、函数执行上下文、eval执行上下文
> 本质上都是 函数上下文

每一个执行上下文 context 本质都是一个对象；
然后在这个对象里面，有函数能访问的对象集合
+ 函数自身变量环境
  + 函数参数
  + 函数内部声明变量
  + 闭包
+ 词法作用域变量环境
  + 外层作用域

**栈的空间不会太大，在其中存放的都是基本数据类型的值，和引用类型的内存指针**



什么样的数据存在栈内？
什么样的数据存在堆内？

除了局部变量，其他的全部存储在堆内；
基本类型存储在栈内，存储的是真实值；
引用类型存储在栈中存储的是指针地址；真实内容存储在堆内。

查看页面内存信息？ 堆信息；栈信息

## 赋值操作

### 值为常量/字面量
```js
const a = 0;
const foo = 'bar';
const obj = { a: 1 }
```
等号右边是确定的值； 这时候是在内存中开辟新的空间，记录这些新的变量声明

### 值为变量
```js
const a = 0;
const b = a;

const obj = { a: 1 };
const ojb = obj;
```
等号右边是已经声明的变量；**这时候是把变量地址赋值给左侧**

### const机制
被const声明的变量，不允许被修改；
其实就是他的内存地址不允许改变


变量重新赋值在内存中是什么表现，是覆盖还是重写&指针替换？

## 闭包
**如何产生的？**
词法作用域的缘故，内层函数会持有外层函数的作用域；
当内层函数作为返回值，暴露给外部变量时；
外部变量也持有了外层函数的作用域；

**如何实现的？**
产生闭包现象之后，被闭包引用的变量会被存储在[[clourse]]对象内，真实值在堆内；
其他未被闭包引用的变量，正常存储在栈内
[[clourse]] 对象是存储在函数的自身变量环境内的



# GC

新生代
老生代

标记清除
引用计数
