# Next、Nest、Nuxt...马什么梅？

当前，前端领域内，除了耳熟能详的Vue、React、Angular这些框架之外，还有一堆名字让人傻傻分不清楚的框架，Next、Nest、Nuxt。。。
本文尝试说清楚这些框架具体是干什么的，当有需要的时候能够快速的选型。

## Express VS Next.js,Nest,Gatsby, and Nuxt

说起这些框架，其实绕不过的就是Express

相对来说，Express框架更偏向于操作HTTP协议，提供一个最小可用的接口。这也是为什么它往往是其他后端框架的基础。

其他的这几个框架，其实是在不同的策略指导下，做的抽象封装，这些抽象需要对框架有深刻的理解。

在介绍这些框架前，先介绍一些web性能指标，因为这些框架基本上都是为了解决这些性能问题的。

## web应用的性能指标

基本上所有的web应用都有共同的目标：`给用户提供高质量的内容`。
这个高质量不仅仅是指`页面内容的高质量`，通常还要求`更好的页面性能`、`更好的SEO`。

SEO很容易理解，当应用部署之后，需要被搜索引擎索引、收录，SEO做得好，能够有更高的几率被搜索引擎推荐。

但是页面性能方面就不太容易定义，没有一个指标能够完美的表达出页面被及时的呈现。
但是，业界也有常用的一系列指标，可以很好的衡量页面的展示过程。

+ `Time to First Byte`(TTFB)
  + TTFB指请求接收到第一个字节的响应，可以衡量服务器响应速率以及客户端和服务器之间的网络状况
+ `First Paint`(FB)
  + 页面的内容开始被渲染，可以配合TTFB衡量页面的渲染开始时间
+ `First Contentful Paint`(FCP)
  + 页面实质性的内容元素开始被渲染，可以是文字或图片，用户此时可以明确感知到页面开始渲染
+ `Largest Contentful Paint`(LCP)
  + 页面的主要元素开始被渲染，用户此时开始可以看到期望的内容
+ `Time to Interactive`(TTI)
  + 用户此时可以参与页面交互，即用户的行为能够得到反馈

> 这些指标也就是chrome提出的`web vitals`

## 渲染策略

宏观层面来讲，所有的web应用的工作机制都是相同的：
客户端发送一个初始请求，服务器返回相应的内容(一般是一个入口的html文件)，然后再触发(也可能没有)后续的一系列请求，最终客户端得到所有需要的数据，然后渲染出页面呈现给用户。

对于静态内容来讲，所有用户看到的都是相同的内容，不需要针对用户差异做额外的计算。HTML和CSS文件都存储在后台，然后按需返回给客户端，客户端接收到之后解析HTML文件，构建DOM树，然后渲染

但是，现实中大多数网站都需要做用户差异化内容，不同的用户或是相同用户在不同时间点访问，会看到不同的内容。这种场景下，就需要在请求过程中做动态分析。

几年前，客户端请求时，服务端会根据具体请求，动态生成HTML文件返回给客户端。客户端接收到的是页面完整的HTML文件，可以直接进入解析、渲染的流程。但是随着一些前端框架(React/Vue)的出现，SPA开始流行起来。

SPA模式下，客户端和服务器之间传递的主要是JS和JSON文件，然后在客户端内执行这些文件，动态生成页面的DOM元素。

`传统模式和SPA都是需要执行代码来动态生成页面元素，但是区别在于何时何地来执行代码`

> 传统模式在服务端，SPA在客户端

这些区别可以称之为不同的渲染策略。

### Client-side Rendering(CSR)

客户端渲染的应用，通常指的就是SPA。

服务端基本上只需要提供在客户端执行的最小化的js代码，通过网络请求获取额外的信息，然后渲染DOM元素。这是当前SPA开发的事实标准

> SPA模式打包产物中index.html内仅有加载所需js的内容，或者是要在首屏优先执行的逻辑，除此之外基本上没有其他的逻辑。所以说是最小化的js代码。

**优点**

1. 扩展性好，因为大部分的计算发生在客户端，服务端不需要做复杂的计算逻辑，同时也会有更快的FB
2. 可以充分利用Web APIs

**缺点**

1. 页面内容是通过网络请求得到的js文件生成的，js下载、执行需要时间，并且会阻塞页面渲染，因此会导致更长的FP、FCP、LCP、TTI
2. 无法做SEO优化，因为页面的内容是JS生成的，无法被搜索引擎的爬虫抓取

### Server-side Rendering(SSR)

与CSR恰恰相反，页面的内容是在服务端计算生成，每次请求时实时生成,返回给客户端完整的页面

所以CSR的优点变成了SSR的缺点，CSR的缺点变成了SSR的优点。

SSR对服务端有很大的考验，因为即使是相同的逻辑也需要在不同的用户请求中重复计算。

### Static Site Genaration(SSG)

SSG，是在应用构建的过程中计算页面内容，通过构建时预计算，聚焦于减少服务端的重复计算，当然会导致更长的构建时间。

这种模式所有的web性能指标都能得到提升，并且能降低服务器成本和增加扩展性。

但是缺点就是，做不到用户的差异性处理，因为产物在构建时已经确定，此时并没有用户差异因素的输入，导致所有用户看到的是相同的内容。

另一个缺点就是，更新的成本，一个细小的更新都需要整个站点的重新构建。也对应催生了 `Incremental Static Regeneration` and `Deferred Site Generation`技术。

> 因此实践中，SSG大多用于博客系统、网站主页等静态站点

### Hybrid rendering strategies – universal/isomorphic apps, hydration, and client-side fetching

上述的三种策略，都是讲计算逻辑放置在单一的一端，要么客户端、服务端，或者构建服务器。每一种策略都有明显的优缺点。

混合渲染策略，则是希望利用各端渲染策略的优缺点，对网页的不同内容，使用不同的渲染策略

+ 对于特定用户元素在客户端渲染
+ 对于通用元素（比如页眉、页脚、about页面等），在服务端渲染

**优点**
除了LCP和TTI指标之外，其他的指标都有很好的提升，并且兼顾SEO，虽然如此，但是LCP和TTI也比SPA有所提升

### 总结

在实际开发中，一个站点可以根据不同的字页面性质，使用多种渲染策略。

以一个电商站点为例

+ 目录和产品橱窗页，可能需要快速渲染并且有好的SEO，就比较适合SSG
+ 购物车，作为有固定格式的用户定制信息，并且不需要考虑SEO，可以考虑使用混合渲染策略，框架用SSR，内容用CSR

如果要开发者自行的维护这些渲染策略，决定哪部分使用CSR，哪部分使用SSR，并且在打包出不同的产物，这就会增加开发的难度。

幸运的是，上述的马冬梅们就是专门来做这件事的。

## 这些框架

这些框架其实就是不同渲染策略的实践

### Gatsby

Gatsby是一个基于React的SSG框架，并且增加了Deferred Site Generation、SSR、CSR等策略

另一个亮点是Gatsby有自己的GraphQL服务器，以提供关于服务器合来自链接源的元数据。

### Next.js

Next.js与Gatsby相似，支持SSG、SSR、 Incremental Static Regeneration 以及 client-side data fetching.

另一个亮点是，支持边缘计算，提供了无服务器执行自定义代码的边缘函数，以及重定向请求到其他主机的边缘中间件。

### NuxtJS

基于Vue
提供上述所有的渲染选项，甚至CSR。
可以用来开发渐进式web应用

丰富的初始化脚手架配置，可以根据需要产出不同的项目

+ 测试框架
+ 构建框架
+ 组件库

所以，Nuxt.js可以算是框架的框架

### Nest

Nest依然名字跟上述框架相似，但是它跟其他框架完全不同，它是用来开发`服务端应用`, 与JAVA中的`Spring`干的是类似的事儿。可以用来实现微服务。它通过对象关系映射器和许多其他协议，如WebSockets、GraphQL和MQTT等，支持几乎所有流行的数据库管理系统。

> 前端框架的打包产物是放置在Nest项目的dist文件夹下的。

## 如何选择

如何选择使用哪个框架呢？可以根据如下的决策树
![frame-choice.webp](https://s2.loli.net/2023/02/19/kzMoHaQjtVlPSsw.webp)
