# 从输入url到页面展示中间发生了什么？


涉及到3个进程之间的数据交互
+ 浏览器进程
+ 网络进程
+ 渲染进程


1. [浏览器进程]  处理用户地址栏输入
   1. 判断是`搜索内容`还是`请求URL`
      1. 搜索内容： 使用浏览器默认的搜索引擎，组装搜索内容，拼接成新的请求URL
      2. 请求URL： 按需补充完整，加上协议等，成为完整的URL
   2. 最终都是URL
2. [浏览器进程]  用户enter确认之后，开始获取新页面流程
   1. 在此之前，给当前页面执行`beforeunload`事件的机会
      1. 可以处理当前页面，做一些数据清理操作
      2. 还可以询问用户是否要离开当前页面，按需取消导航，不再进行后续工作
   2. 如果没有`beforeunload`事件，或者用户确认离开，就开始新地址的加载流程
      1. 标签页图标变成加载状态
      2. 当前页面还是上一个页面
3. [网络进程]  URL请求过程 
   1. 浏览器进程会通过IPC把URL发送至网络进程，在网络进程发起真正的URL请求
      1. 检查缓存
         1. 有缓存资源，直接返回给浏览器进程
         2. 没有缓存资源，进入到网络请求流程
      2. DNS解析 获取Ip地址
      3. 利用IP地址，和服务器建立TCP连接
         1. 如果是HTTPS请求，还需要建立TLS连接
      4. 浏览器构建请求行、请求头信息，附加cookie等信息，发送HTTP请求
      5. 服务器接收到请求信息之后，根据请求信息生成响应数据
         1. 重定向
            1. 状态码 301、302、307、308
            2. 根据相应头内的Location字段指定的URL，重新发起请求
         2. 正常返回响应数据
            1. 根据请求头`Content-Type`区分是正常页面还是下载或是api请求
               1. text/Html html页面
                  1. 浏览器继续进行导航流程
                  2. `通知浏览器进程开始准备一个渲染进程`
                     1. chrome默认条件下是每个tab标签页对应一个渲染进程
                     2. 当从一个页面打开另一个页面，并且两个页面符合 schema + same-site 的规则，那么2个页面复用同一个渲染进程
                        1. schema + same-site  协议一致并且符合same-site规则会复用当前渲染进程
                        2. 但是 设置了`rel=noopener noreferrer`属性的a标签，及时符合上述条件也会新建流程
                        3. 新版的浏览器默认设置`rel=noopener`在有`target=_blank`的标签上
               2. application/octet-stream   下载
                  1. 请求被提交到浏览器的下载管理器，url请求的导航流程结束
               3. application/json  api请求 json数据
            2. 根据请求头信息，识别出html页面，通知浏览器进程开始准备渲染进程
4. [渲染进程] 提交文档 浏览器进程将网络进程接收到的HTML文档提交给渲染进程
   1. 渲染进程准备完毕之后，浏览器进程向渲染进程发起`提交文档`的消息
   2. 渲染进程接收到消息，和网络进程建立数据传输的管道，开始数据传输HTML文档
   3. 渲染进程接收完毕之后，返回`确认提交`的消息给浏览器进程
   4. 浏览器进程更新界面状态，包括安全状态、地址栏url、前进后退的历史状态，开始更新web页面
5. [渲染进程] 渲染阶段
   1. **页面解析**，子资源加载, 流式的解析html构建DOM树，遇到css和js加载，就暂停html解析，加载资源并解析
      1. 引申出html中各种资源的书写位置 最优方案
   2. **DOM树构建**  
      1. 输入：HTML
      2. 输出：DOM
      3. DOM是渲染引擎的内部数据结构，同是也暴露给JS引擎，V8对其封装后成api来查询或修改
   3. **样式计算**  计算出DOM节点中每个元素的具体样式
      1. 将各种类型引入的css规则转换为层叠结构 `styleSheets`
         1. 三种样式来源
            1. link
            2. style标签
            3. 元素内嵌CSS
         2. styleSheets 对象同时也具备了查询和修改功能
      2. 转换某些属性值为标准化值
      3. 计算出DOM树中每个节点的具体样式
         1. 继承： 每个DOM节点都包含父节点的样式
         2. 层叠： 定义如何合并来自多个源的属性值
            1. 选择器优先级
            2. 样式权重
   4. **布局阶段** 计算出DOM树中可见元素的几何位置
      1. 创建布局树  renderTree 只包含页面中展示的元素
      2. 布局计算 计算树中各个节点的坐标位置
   5. **分层** 为特定的节点生成专用的图层，并生成一棵对应的图层树
      1. 满足什么条件渲染引擎才会为特定的节点创建新的图层呢？
         1. 拥有层叠上下文属性的元素
            1. 定位
            2. 透明
            3. 滤镜 filter
         2. 需要剪裁的地方
   6. **图层绘制** 
      1. 渲染引擎按图层绘制
         1. 每个图层内容又拆分为多个`绘制指令`, 组成待绘制列表
      2. 这一步只是拆分绘制任务，生成绘制指令列表，没有实际发生绘制
   7. **栅格化操作**
      1. 实际绘制是由渲染引擎中的`合成线程`来完成的
      2. 按需渲染 图层内容可能很大，全量渲染会耗费性能
         1. 渲染视口内的内容
      3. 合成线程会将图层划分为图块，优先将视口附近的图块生成`位图`
      4. 位图的生成操作是由栅格化来执行的，所谓的栅格化就是`将图块转化成位图`
      5. 渲染进程维护了一个栅格化的线程池。所有图块的栅格化都是在线程池内完成的
      6. 通常栅格化的过程会使用GPU来加速，生成的位图保存在GPU内存中
   8. **合成和显示**
      1. 所有需要显示的图块光栅化完成之后，合成线程通知浏览器进程
      2. 浏览器进程调用viz组件，绘制页面内容，显示在屏幕上
      3. 页面绘制完成，通知浏览器进程，停止标签页的加载动画，展示favicon.ico



## 关键概念
### 重绘&重排&合成
重排： 更新了元素的几何属性，宽、高、位置
   需要更新完整的渲染流水线，开销最大
重绘： 更新元素的绘制属性； 颜色
   需要从绘制阶段开始更新，跳过了布局和分层阶段，执行效率比重排要高
合成： 元素没有布局和绘制属性的变更，只执行合成操作， transform
   合成不需要重绘、重排，直接在某个图层上从栅格化阶段开始
   在合成线程上操作的，不会占用主线程资源，
   效率最高
#### 哪些操作能减少重绘重排？
1. 批量操作dom，触发dom重绘重排的操作尽量何在一起
2. will-change： transform 分层



## Q&A
1. **CSS文件阻塞了，会阻塞DOM树的合成吗？**     
当渲染进程从网络进程流式接受html文档时，DOM解析就会开始了；    
如果遇到JS脚本<script>内联脚本
   DOM解析器会暂停。执行JS脚本
如果遇到外部JS文件
   暂停DOM解析
   下载js文件
   执行js文件
   继续解析DOM
如果遇到的JS，并且JS代码访问了某个元素的样式
   就需要样式文件下载完成，才能继续执行JS
   这种情况下CSS就阻塞了DOM解析； CSS阻塞JS执行、进而阻塞DOM解析

   **DOM树构建和CSS styleSheets构建是否是并行的？**

