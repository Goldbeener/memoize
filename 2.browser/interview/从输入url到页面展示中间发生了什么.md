# 从输入url到页面展示中间发生了什么？


涉及到3个进程之间的数据交互
+ 浏览器进程
+ 网络进程
+ 渲染进程


1. [浏览器进程]  处理用户地址栏输入
   1. 判断是`搜索内容`还是`请求URL`
      1. 搜索内容： 使用浏览器默认的搜索引擎，组装搜索内容，拼接成新的请求URL
      2. 请求URL： 按需补充完整，加上协议等，成为完整的URL
   2. 最终都是URL
2. [浏览器进程]  用户enter确认之后，开始获取新页面流程
   1. 在此之前，给当前页面执行`beforeunload`事件的机会
      1. 可以处理当前页面，做一些数据清理操作
      2. 还可以询问用户是否要离开当前页面，按需取消导航，不再进行后续工作
   2. 如果没有`beforeunload`事件，或者用户确认离开，就开始新地址的加载流程
      1. 标签页图标变成加载状态
      2. 当前页面还是上一个页面
3. [网络进程]  URL请求过程 
   1. 浏览器进程会通过IPC把URL发送至网络进程，在网络进程发起真正的URL请求
      1. 检查缓存
         1. 有缓存资源，直接返回给浏览器进程
         2. 没有缓存资源，进入到网络请求流程
      2. DNS解析 获取Ip地址
      3. 利用IP地址，和服务器建立TCP连接
         1. 如果是HTTPS请求，还需要建立TLS连接
      4. 浏览器构建请求行、请求头信息，附加cookie等信息，发送HTTP请求
      5. 服务器接收到请求信息之后，根据请求信息生成响应数据
         1. 重定向
            1. 状态码 301、302、307、308
            2. 根据相应头内的Location字段指定的URL，重新发起请求
         2. 正常返回响应数据
            1. 根据请求头`Content-Type`区分是正常页面还是下载或是api请求
               1. text/Html html页面
                  1. 浏览器继续进行导航流程
                  2. `通知浏览器进程开始准备一个渲染进程`
                     1. chrome默认条件下是每个tab标签页对应一个渲染进程
                     2. 当从一个页面打开另一个页面，并且两个页面符合 schema + same-site 的规则，那么2个页面复用同一个渲染进程
                        1. schema + same-site  协议一致并且符合same-site规则会复用当前渲染进程
                        2. 但是 设置了`rel=noopener noreferrer`属性的a标签，及时符合上述条件也会新建流程
                        3. 新版的浏览器默认设置`rel=noopener`在有`target=_blank`的标签上
               2. application/octet-stream   下载
                  1. 请求被提交到浏览器的下载管理器，url请求的导航流程结束
               3. application/json  api请求 json数据
            2. 根据请求头信息，识别出html页面，通知浏览器进程开始准备渲染进程
4. [渲染进程] 提交文档 浏览器进程将网络进程接收到的HTML文档提交给渲染进程
   1. 渲染进程准备完毕之后，浏览器进程向渲染进程发起`提交文档`的消息
   2. 渲染进程接收到消息，和网络进程建立数据传输的管道，开始数据传输HTML文档
   3. 渲染进程接收完毕之后，返回`确认提交`的消息给浏览器进程
   4. 浏览器进程更新界面状态，包括安全状态、地址栏url、前进后退的历史状态，开始更新web页面
5. [渲染进程] 渲染阶段
   1. 页面解析，子资源加载, 流式的解析html构建DOM树，遇到css和js加载，就暂停html解析，加载资源并解析
   2. DOM树构建  
      1. 输入：HTML
      2. 输出：DOM
      3. DOM是渲染引擎的内部数据结构，同是也暴露给JS引擎，V8对其封装后成api来查询或修改
   3. 样式计算
      1. 将各种
   4. 页面绘制完成，通知浏览器进程，停止标签页的加载动画，展示favicon.ico
